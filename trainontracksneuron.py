# -*- coding: utf-8 -*-
"""
Created on Wed Nov 18 15:56:50 2020

@author: 15185
"""


# -*- coding: utf-8 -*-
import math
import time as time
import numpy as np
import matplotlib.pyplot as plt
import newnerrriin as self
import random
import SCOTT
from SCOTT import Fifthdimensional



def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 



class Node:
                def __init__(self,data):
                    self.data= data
                    self.next= None
                    self.prev= None

class stack:
                
                def __init__(self):
                    
                   self.head= None
                   
                def push(self,data):
                    
                    if self.head is None:
                        self.head= Node(data)
                    else:
                        new_node= Node(data)
                        self.head.prev= new_node
                        new_node.next= self.head
                        new_node.prev= None
                        self.head= new_node
                        
                def pop(self):
                    if self.head is None:
                        return None
                    elif self.head.next is None:
                        temp= self.head.data
                        self.head= None
                        return temp
                    else:
                        temp= self.head.data
                        self.head= self.head.next
                        self.head.prev= None
                        return temp
                
                def top(self):
                    return self.head.data
                
                def size(self):
                    temp= self.head
                    count= 0
                    while temp is not None:
                     count = count+1
                     temp= temp.next
                    return count
                 
                # Function to check if the stack is empty or not   
                def isEmpty(self): 
              
                    if self.head is None: 
                       return True
                    else: 
                       return False
                   
                def printstack(self):
                     
                     print('stack elements are:')
                     temp= self.head
                     while temp is not None:
                        print(temp.data, end ="->")
                        temp=(temp.next)
stack = stack()

# array of any amount of numbers. n = m
X = np.array([[1, 2, 3],
              [3, 4, 1],
              [2, 5, 3]])
                
# multiplication
y = np.array([[.5, .3, .2]])
  
# transpose of y
y = y.T
  
# sigma value
sigm = 2
  
# find the delta
delt = np.random.random((3, 3)) - 1
  
for j in range(100):
    # find matrix 1. 100 layers. 
    m1 = (y - (1/(1 + np.exp(-(np.dot((1/(1 + np.exp(
                   -(np.dot(X, sigm))))), delt))))))*((1/(
                       1 + np.exp(-(np.dot((1/(1 + np.exp(
                   -(np.dot(X, sigm))))), delt)))))*(1-(1/(
                       1 + np.exp(-(np.dot((1/(1 + np.exp(
                   -(np.dot(X, sigm))))), delt)))))))
                     
    # find matrix 2
    m2 = m1.dot(delt.T) * ((1/(1 + np.exp(-(np.dot(X, sigm)))))
                    * (1-(1/(1 + np.exp(-(np.dot(X, sigm)))))))
    # find delta
    delt = delt + (1/(1 + np.exp(-(np.dot(X, sigm))))).T.dot(m1)
      
    # find sigma
    sigm = sigm + (X.T.dot(m2))
      
# print output from the matrix
print(1/(1 + np.exp(-(np.dot(X, sigm)))))
#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=9
INaOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INaOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INaOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INaOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INaOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)
stack.push(self)
#updates top values
INaOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^ 
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]



Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)



def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)
#########################################################################################small A


def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=99
INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)
stack.push(self)
#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)

errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6A=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6cA=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)

##########################################################################################################3RD START

class Node:
    def __init__(self,data):
        self.data= data
        self.next= None
        self.prev= None
        
class stack:
    def __init__(self):
        
       self.head= None
       
    def push(self,data):
        
        if self.head is None:
            self.head= Node(data)
        else:
            new_node= Node(data)
            self.head.prev= new_node
            new_node.next= self.head
            new_node.prev= None
            self.head= new_node
            
    def pop(self):
        if self.head is None:
            return None
        elif self.head.next is None:
            temp= self.head.data
            self.head= None
            return temp
        else:
            temp= self.head.data
            self.head= self.head.next
            self.head.prev= None
            return temp
    
    def top(self):
        return self.head.data
    
    def size(self):
        temp= self.head
        count= 0
        while temp is not None:
         count = count+1
         temp= temp.next
        return count
     
    # Function to check if the stack is empty or not   
    def isEmpty(self): 
  
        if self.head is None: 
           return True
        else: 
           return False
       
    def printstack(self):
         
         print('stack elements are:')
         temp= self.head
         while temp is not None:
            print(temp.data, end ="->")
            temp=(temp.next)
            
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

if __name__=='__main__':
    time.time()/10000000000
    stack=stack()
    stack.push(self)
    stack.push(id(id(id(id(id(id(id(id(id(self))))))))))
    stack.push(math.sqrt(time.time())/100000000)
    stack.push(NODE)
    stack.push(NODEOUT)
    stack.push(RHfact8)
    stack.push(RHfalse8)
    stack.push(Yh)
    
    stack.push(Zh)
    stack.push(theth)
    stack.push(dvsh)
    stack.printstack()
    print("\n top element is:", stack.top())
    print('size of the stack is:', stack.size())
    stack.pop()
    stack.pop()
    stack.printstack()
    print('\n stack is empty:',stack.isEmpty())   
    
    
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-__---____-__--_-BEGINING OF THE END 2
#*******************************************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
self=99
INOUT= [self,move6A,move6cA,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Valuen
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)



def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)
#########################################################################################small A


def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=99
INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)

##########################################################################################################3RD START

class Node:
    def __init__(self,data):
        self.data= data
        self.next= None
        self.prev= None
        
class stack:
    def __init__(self):
        
       self.head= None
       
    def push(self,data):
        
        if self.head is None:
            self.head= Node(data)
        else:
            new_node= Node(data)
            self.head.prev= new_node
            new_node.next= self.head
            new_node.prev= None
            self.head= new_node
            
    def pop(self):
        if self.head is None:
            return None
        elif self.head.next is None:
            temp= self.head.data
            self.head= None
            return temp
        else:
            temp= self.head.data
            self.head= self.head.next
            self.head.prev= None
            return temp
    
    def top(self):
        return self.head.data
    
    def size(self):
        temp= self.head
        count= 0
        while temp is not None:
         count = count+1
         temp= temp.next
        return count
     
    # Function to check if the stack is empty or not   
    def isEmpty(self): 
  
        if self.head is None: 
           return True
        else: 
           return False
       
    def printstack(self):
         
         print('stack elements are:')
         temp= self.head
         while temp is not None:
            print(temp.data, end ="->")
            temp=(temp.next)
            
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE4^


def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
INaOUT.pop(int(self))
#"Remember, what i say is what i said, not what im saying" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE5^
if __name__=='__main__':
    time.time()/10000000000
    stack=stack()
    stack.push(self)
    stack.push(id(id(id(id(id(id(id(id(id(self))))))))))
    stack.push(math.sqrt(time.time())/100000000)
    stack.push(NODE)
    stack.push(NODEOUT)
    stack.push(RHfact8)
    stack.push(RHfalse8)
    stack.push(Yh)
    
    stack.push(Zh)
    stack.push(theth)
    stack.push(dvsh)
    stack.printstack()
    print("\n top element is:", stack.top())
    print('size of the stack is:', stack.size())
    stack.pop()
    stack.pop()
    stack.printstack()
    print('\n stack is empty:',stack.isEmpty())   

###########################################################################################################INOUTB
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=99
INbOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INbOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INbOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INbOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INbOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INbOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^ 
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)



def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)
#########################################################################################small A


def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=99
INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6A=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6cA=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)

##########################################################################################################3RD START

class Node:
    def __init__(self,data):
        self.data= data
        self.next= None
        self.prev= None
        
class stack:
    def __init__(self):
        
       self.head= None
       
    def push(self,data):
        
        if self.head is None:
            self.head= Node(data)
        else:
            new_node= Node(data)
            self.head.prev= new_node
            new_node.next= self.head
            new_node.prev= None
            self.head= new_node
            
    def pop(self):
        if self.head is None:
            return None
        elif self.head.next is None:
            temp= self.head.data
            self.head= None
            return temp
        else:
            temp= self.head.data
            self.head= self.head.next
            self.head.prev= None
            return temp
    
    def top(self):
        return self.head.data
    
    def size(self):
        temp= self.head
        count= 0
        while temp is not None:
         count = count+1
         temp= temp.next
        return count
     
    # Function to check if the stack is empty or not   
    def isEmpty(self): 
  
        if self.head is None: 
           return True
        else: 
           return False
       
    def printstack(self):
         
         print('stack elements are:')
         temp= self.head
         while temp is not None:
            print(temp.data, end ="->")
            temp=(temp.next)
            
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

if __name__=='__main__':
    time.time()/10000000000
    stack=stack()
    stack.push(self)
    stack.push(id(id(id(id(id(id(id(id(id(self))))))))))
    stack.push(math.sqrt(time.time())/100000000)
    stack.push(NODE)
    stack.push(NODEOUT)
    stack.push(RHfact8)
    stack.push(RHfalse8)
    stack.push(Yh)
    
    stack.push(Zh)
    stack.push(theth)
    stack.push(dvsh)
    stack.printstack()
    print("\n top element is:", stack.top())
    print('size of the stack is:', stack.size())
    stack.pop()
    stack.pop()
    stack.printstack()
    print('\n stack is empty:',stack.isEmpty())   
    
    
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-__---____-__--_-BEGINING OF THE END 2
#*******************************************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
self=99
INOUT= [self,move6A,move6cA,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)



def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)
#########################################################################################small A


def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=99
INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

RHfact8=math.cos(r3h)
R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE1^
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END
self=NEUROTRANSMITTER

INOUT= [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)


# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMiTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4
RHfalse8=math.sin(r3h)
R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR.T,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)

##########################################################################################################3RD START

class Node:
    def __init__(self,data):
        self.data= data
        self.next= None
        self.prev= None
        
class stack:
    def __init__(self):
        
       self.head= None
       
    def push(self,data):
        
        if self.head is None:
            self.head= Node(data)
        else:
            new_node= Node(data)
            self.head.prev= new_node
            new_node.next= self.head
            new_node.prev= None
            self.head= new_node
            
    def pop(self):
        if self.head is None:
            return None
        elif self.head.next is None:
            temp= self.head.data
            self.head= None
            return temp
        else:
            temp= self.head.data
            self.head= self.head.next
            self.head.prev= None
            return temp
    
    def top(self):
        return self.head.data
    
    def size(self):
        temp= self.head
        count= 0
        while temp is not None:
         count = count+1
         temp= temp.next
        return count
     
    # Function to check if the stack is empty or not   
    def isEmpty(self): 
  
        if self.head is None: 
           return True
        else: 
           return False
       
    def printstack(self):
         
         print('stack elements are:')
         temp= self.head
         while temp is not None:
            print(temp.data, end ="->")
            temp=(temp.next)
            
def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append(move3a)
out2.append(move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.                                       remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=                                  deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
#"if i did not find what love really means I would not of found who I truley am" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE4^


def sigmoid(self):
    if self < 0:
        return np.exp(self)/(1+np.exp(self))
    else:
       return 1/(1+np.exp(-self))
def deriv(self):
        y = self**2 + 1
        return y 

#########-_-----------__--__--_----___----_____--_-_-__-_-_-____-___-___--____-_BEGINING OF THE END

INOUT= [self,RHfact8,RHfalse8,self]
WT1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=INOUT[0]
A=self*WT1[0]
B=self*WT1[1]
C=self*WT1[2]
D=self*WT1[3]
self=INOUT[1]
E=self*WT1[0]
F=self*WT1[1]
G=self*WT1[2]
H=self*WT1[3]
self=INOUT[2]
I=self*WT1[0]
J=self*WT1[1]
K=self*WT1[2]
L=self*WT1[3]
INOUT.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
ra=R1/4
rra=ra/10
rrra=rra/89
eye=math.tanh(ra)/3
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3a=-R5/89
rr3a=r3a/10
rrr3a=rr3a/4

R=np.vdot(R1,R5)
SIR=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ya=math.sinh(X)
theta=math.degrees(self)
Za=math.hypot(self,Ya)
dvsa=deriv(self)

#updates top values
INOUT.pop(int(self))
WT1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theta)+Ya*math.sin(theta)
V=Ya*math.cos(theta)+self*math.sin(theta)
errora=100/45*(theta-45)
erroraa=[errora]
tha=45-theta
w1s=(self+U)
w1y=(Ya+V)
w1new=[self,Ya,dvsa,errora]

Δ.append(U)
Δ.append(V)

#meaning/time=wt
a1=self
self=a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=[self,Ya,Za,theta,dvsa]
print(outputa)

# ___________________________________________________________________________a1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
#plt.axis([-8,8,-8,8]), x=[self,self,-self,-self,self], y=[Ya,-Ya,-Ya,Ya,-Ya], plt.xlabel('LOW Y'), plt.ylabel('HIGH X'), plt.grid(), plt.plot(xy)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)plt.show()self=w1s
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ya),radius=Za*2,fill=None,color='green')
c2=plt.Circle((-self,Ya),radius=Za*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ya),radius=Za*2,fill=None,color='red')
c4=plt.Circle((self,-Ya),radius=Za*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
#plt.yticks(rotation=90)
#plt.scatter(x, y, s=80, facecolors='none', edgecolors='r')
#plt.Circle((2,3),radius=5)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------A1
inout= [self,Ya,Za,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rb=R1/4
rrb=rb/10
rrrb=rrb/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3b=-R5/89
rr3b=r3b/10
rrr3b=rr3b/4

R=np.vdot(R1,R5)
SIR1=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yb=math.sinh(X)
thetb=math.degrees(self)
Zb=math.hypot(self,Yb)
dvsb=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetb)+Yb*math.sin(thetb)
V=Yb*math.cos(thetb)+self*math.sin(thetb)
errorb=100/45*(thetb-45)
errorbb=[errorb]
thb=45-thetb
w1s=(self+U)
w1y=(Yb+V)
w1new=[self,Yb,dvsb,errorb]
w1.append(self-1), w1.append(Yb),w1.append(dvsb),w1.append(errorb)
Δ.append(U)
Δ.append(V)
Taim=errorb+(thetb)
#meaning/time=wt
b1=self
self=b1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputb=[self,Yb,Zb,thetb,dvsb]
print(outputb)


# ___________________________________________________________________________b1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yb),radius=Zb*2,fill=None,color='green')
c2=plt.Circle((-self,Yb),radius=Zb*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yb),radius=Zb*2,fill=None,color='red')
c4=plt.Circle((self,-Yb),radius=Zb*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------b1^
inout= [self,Yb,Zb,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rc=R1/4
rrc=rc/10
rrrc=rrc/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3c=-R5/89
rr3c=r3c/10
rrr3c=rr3c/4

R=np.vdot(R1,R5)
SIR2=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yc=math.sinh(X)
thetc=math.degrees(self)
Zc=math.hypot(self,Yc)
dvsc=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetc)+Yc*math.sin(thetc)
V=Yc*math.cos(thetc)+self*math.sin(thetc)
errorc=100/45*(thetc-45)
errorcc=[errorc]
thc=45-thetc
w1s=(self+U)
w1y=(Yc+V)
w1new=[self,Yc,dvsc,errorc]
w1.append(self-1), w1.append(Yc),w1.append(dvsc),w1.append(errorc)
Δ.append(U)
Δ.append(V)
Taim=errorc+(thetc)
#meaning/time=wt
c1=self
self=c1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputc=[self,Yc,Zc,thetc,dvsc]
print(outputc)
# ___________________________________________________________________________c1
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yc),radius=Zc*2,fill=None,color='green')
c2=plt.Circle((-self,Yc),radius=Zc*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yc),radius=Zc*2,fill=None,color='red')
c4=plt.Circle((self,-Yc),radius=Zc*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------c1^
inout= [self,Yc,Zc,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rd=R1/4
rrd=rd/10
rrrd=rrd/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3d=-R5/89
rr3d=r3c/10
rrr3d=rr3c/4

R=np.vdot(R1,R5)
SIR3=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yd=math.sinh(X)
thetd=math.degrees(self)
Zd=math.hypot(self,Yd)
dvsd=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetd)+Yd*math.sin(thetd)
V=Yd*math.cos(thetd)+self*math.sin(thetd)
errord=100/45*(thetd-45)
errordd=[errord]
thd=45-thetd
w1s=(self+U)
w1y=(Yd+V)
w1new=[self,Yd,dvsd,errord]
w1.append(self-1), w1.append(Yd),w1.append(dvsd),w1.append(errord)
Δ.append(U)
Δ.append(V)
Taim=errord+(thetd)
#meaning/time=wt
d1=self
self=d1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputd=[self,Yd,Zd,thetd,dvsd]
print(outputd)

# ___________________________________________________________________________d1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yd),radius=Zd*2,fill=None,color='green')
c2=plt.Circle((-self,Yd),radius=Zd*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yd),radius=Zd*2,fill=None,color='red')
c4=plt.Circle((self,-Yd),radius=Zd*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()

# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------d1^
inout= [self,Yd,Zd,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
re=R1/4
rre=re/10
rrre=rre/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3e=-R5/89
rr3e=r3e/10
rrr3e=rr3e/4

R=np.vdot(R1,R5)
SIR4=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Ye=math.sinh(X)
thete=math.degrees(self)
Ze=math.hypot(self,Ye)
dvse=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thete)+Ye*math.sin(thete)
V=Ye*math.cos(thete)+self*math.sin(thete)
errore=100/45*(thete-45)
erroree=[errore]
the=45-thete
w1s=(self+U)
w1y=(Ye+V)
w1new=[self,Ye,dvse,errore]
w1.append(self-1), w1.append(Ye),w1.append(dvse),w1.append(errore)
Δ.append(U)
Δ.append(V)
Taim=errore+(thete)
#meaning/time=wt
e1=self
self=e1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outpute=[self,Ye,Ze,thete,dvse]
print(outpute)

# ___________________________________________________________________________e1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Ye),radius=Ze*2,fill=None,color='green')
c2=plt.Circle((-self,Ye),radius=Ze*2,fill=None,color='blue')
c3=plt.Circle((-self,-Ye),radius=Ze*2,fill=None,color='red')
c4=plt.Circle((self,-Ye),radius=Ze*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------e1^
inout= [self,Ye,Ze,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rf=R1/4
rrf=rf/10
rrrf=rrf/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3f=-R5/89
rr3f=r3f/10
rrr3f=rr3f/4

R=np.vdot(R1,R5)
SIR5=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yf=math.sinh(X)
thetf=math.degrees(self)
Zf=math.hypot(self,Yf)
dvsf=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetf)+Yf*math.sin(thetf)
V=Yf*math.cos(thetf)+self*math.sin(thetf)
errorf=100/45*(thetf-45)
errorff=[errorf]
thf=45-thetf
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yf,dvsf,errorf]
w1.append(self-1), w1.append(Yf),w1.append(dvsf),w1.append(errorf)
Δ.append(U)
Δ.append(V)
Taim=errorf+(thetf)
#meaning/time=wt
f1=self
self=f1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputf=[self,Yf,Zf,thetf,dvsf]
print(outputf)

# ___________________________________________________________________________f1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yf),radius=Zf*2,fill=None,color='green')
c2=plt.Circle((-self,Yf),radius=Zf*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yf),radius=Zf*2,fill=None,color='red')
c4=plt.Circle((self,-Yf),radius=Zf*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------f1^
inout= [self,Yf,Zf,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rg=R1/4
rrg=rg/10
rrrg=rrg/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3g=-R5/89
rr3g=r3g/10
rrr3g=rr3g/4

R=np.vdot(R1,R5)
SIR6=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yg=math.sinh(X)
thetg=math.degrees(self)
Zg=math.hypot(self,Yg)
dvsg=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(thetg)+Yg*math.sin(thetg)
V=Yg*math.cos(thetg)+self*math.sin(thetg)
errorg=100/45*(thetg-45)
errorgg=[errorg]
thg=45-thetg
w1s=(self+U)
w1y=(Yf+V)
w1new=[self,Yg,dvsg,errorg]
w1.append(self-1), w1.append(Yg),w1.append(dvsg),w1.append(errorg)
Δ.append(U)
Δ.append(V)
Taim=errorg+(thetg)
#meaning/time=wt
g1=self
self=g1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputg=[self,Yg,Zg,thetg,dvsg]
print(outputg)

# ___________________________________________________________________________g1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yg),radius=Zg*2,fill=None,color='green')
c2=plt.Circle((-self,Yg),radius=Zg*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yg),radius=Zg*2,fill=None,color='red')
c4=plt.Circle((self,-Yg),radius=Zg*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------g1^
inout= [self,Yg,Zg,self]
w1=    [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=  [math.sqrt(time.time())/100000000]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
    
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=np.array(M)
Q2=np.array(N)
Q3=np.array(O)
Q4=np.array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=np.dot(Q1,Q3)
r2=math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR7=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)
errorhh=[errorh]
thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh)

# ___________________________________________________________________________h1
#PLOT SPACE.....NEURO TRANSMIT full 360 degree turn square,circle,color RED
plt.axis([-4,4,-4,4])
x=[-self,self,-self,self,-self]
y=[self,-self,-self,self,self]
plt.xlabel('LOW Y')
plt.ylabel('HIGH X')
plt.grid()
plt.plot(x,y)
c1=plt.Circle((self,Yh),radius=Zh*2,fill=None,color='green')
c2=plt.Circle((-self,Yh),radius=Zh*2,fill=None,color='blue')
c3=plt.Circle((-self,-Yh),radius=Zh*2,fill=None,color='red')
c4=plt.Circle((self,-Yh),radius=Zh*2,fill=None,color='black')
plt.gca().add_artist(c1)
plt.gca().add_artist(c2)
plt.gca().add_artist(c3)
plt.gca().add_artist(c4)
plt.show()
# _NEUROTRANSMUTTERS ^^^^^^^^^^^^^^^^^^^^^^__________________________________________----------------------h1^
inout= [errora,errorb,errorc,self]
w1=    [errord,errore,errorf,errorg]
bias=  [errorh]

Δ=['self','soul']

self=inout[0]
A=self*w1[0]
B=self*w1[1]
C=self*w1[2]
D=self*w1[3]
self=inout[1]
E=self*w1[0]
F=self*w1[1]
G=self*w1[2]
H=self*w1[3]
self=inout[2]
I=self*w1[0]
J=self*w1[1]
K=self*w1[2]
L=self*w1[3]
inout.remove(self)
AVERAGE=(errora+errorb+errorc+errord+errore+errorf+errorg+errorh)/8
erroraa.clear(),errorbb.clear(),errorcc.clear(),errordd.clear(),erroree.clear(),errorff.clear(),errorgg.clear(),errorhh.clear()
erroraa.append(AVERAGE)
errorbb.append(AVERAGE)
errorcc.append(AVERAGE)
errordd.append(AVERAGE)
erroree.append(AVERAGE)
errorff.append(AVERAGE)
errorgg.append(AVERAGE)
errorhh.append(AVERAGE)
M=A+E+I+bias[0]
N=B+F+J+bias[0] 
O=C+G+L+bias[0]
P=D+H+L+bias[0]
    
Q1=                                                                                   np.array(M)
Q2=                                                                   np.array(N)
Q3=                   np.array(O)
Q4=np.                                   array(P)
    
R1=np.dot(Q1,Q2, out=None)
rh=R1/4
rrh=rh/10
rrrh=rrh/89
    
R2=                                                                          np.dot(Q1,Q3)
r2                                                                                                =math.cos(R2)
R3=np.dot(Q2,Q3)
r3=math.cos(R3)
R4=np.dot(Q2,Q4)
r4=math.cos(R4)
    
R5=np.dot(Q3,Q4, out=None)
r3h=-R5/89
rr3h=r3h/10
rrr3h=rr3h/4

R=np.vdot(R1,R5)
SIR8=deriv(R)
def funcX(self):
    if  0 < r3:
        self=r3
        return self
    elif 0 < r2:
        self=r2
        return self
    elif 0 < r4:
        self=r4
        return self
    else:
        self=R
        return R
funcX(self)
self=funcX(self)
X=sigmoid(self)
self=X
self=math.cos(X)
Yh=math.sinh(X)
theth=math.degrees(self)
Zh=math.hypot(self,Yh)
dvsh=deriv(self)

#updates top values
inout.pop(int(self))
w1.clear()
Δ.remove('self')
Δ.remove('soul')
#ROTATION Value
U=self*math.cos(theth)+Yh*math.sin(theth)
V=Yh*math.cos(theth)+self*math.sin(theth)
errorh=100/45*(theth-45)

thh=45-theth
w1s=(self+U)
w1y=(Yh+V)
w1new=[self,Yh,dvsh,errorh]
w1.append(self-1), w1.append(Yh),w1.append(dvsh),w1.append(errorh)
Δ.append(U)
Δ.append(V)
Taim=errorh+(theth)
#meaning/time=wt
h1=self
self=h1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputh=[self,Yh,Zh,theth,dvsh]
print(outputh,AVERAGE)

#_______________________________________________________________________________#######
w1=    [SIR,SIR1,SIR2,SIR3,SIR4,SIR5,SIR6,SIR7,SIR8]
inout= [errora,errorb,errorc,errord]
asBI=  [math.sqrt(time.time())/100000000]
outin= []
#__________________________

in1=  [1,2]
bi1=  [math.sqrt(time.time())/100000000]
out1=[errore,2]
#___________________________

in2= [1,2]
bi2=  [math.sqrt(time.time())/100000000]
out2=[1,2]
#___________________________

in4= [1,2]
bi4=  [math.sqrt(time.time())/100000000]
out4=[errorf,2]

#___________________________

in5= [1,2]
bi5=  [math.sqrt(time.time())/100000000]
out5=[errorg,2]
#___________________________

in7= [1,2]
bi7=  [math.sqrt(time.time())/100000000]
out7=[1,2]
#___________________________

in8= [1,2]
bi8= [math.sqrt(time.time())/100000000]
out8=[errorh,2]
#___________________________


Δ=['self','soul']


move1=sigmoid(inout[0]*w1[0]+bi5[0])
move1a=sigmoid(inout[1]*w1[1]+bi8[0])
move1b=sigmoid(inout[2]*w1[2]+bi1[0])
move1c=sigmoid(inout[3]*w1[3]+bi4[0])
NODEOUT=[move1,move1a,move1b,move1c]

inout.clear()
outin.clear()

outin.append(NODEOUT)
in1.remove(in1[1])
in8.remove(in8[1])
in4.remove(in4[1])
in5.remove(in5[1])
in1.append(move1)
in8.append(move1c)
in4.append(move1a)
in5.append(move1b)

move2=sigmoid(in8[0]*w1[4]+bi8[0])
move2a=sigmoid(in5[0]*w1[4]+bi5[0])
move2b=sigmoid(in7[0]*w1[4]*bi7[0])
move2c=sigmoid(in7[1]*w1[4]*bi7[0])
in7.clear()
out7.clear()
in7.append(move2)
in7.append(move2a)
out7.append(move2b)
out7.append(move2c)

move3=sigmoid(in1[0]*w1[5]+bi1[0])
move3a=sigmoid(in4[0]*w1[5]+bi4[0])
move3b=sigmoid(in2[0]*w1[5]*bi2[0])
move3c=sigmoid(in2[1]*w1[5]*bi2[0])
in2.clear()
out2.clear()
in2.append(move3)
in2.append                                                (move3a)
out2.append                                                              (move3b)
out2.append(move3c)

move4=deriv(out7[0]*w1[6]+bi7[0])
move4a=deriv(out7[1]*w1[6]+bi7[0])
out8.remove(out8[1])
out8.append(move4)
out5.remove(out5[1])
out5.append(move4a)

move5=deriv(out2[0]*w1[6]+bi2[0])
move5a=deriv(out2[1]*w1[6]+bi2[0])
out1.remove(out1[1])
out1.append(move5)
out4.remove(out4[1])
out4.append(move5a)

move6=deriv(out8[0]*w1[7]+bi8[0])
move6a=deriv(out1[0]*w1[7]+bi1[0])
move6b=deriv(out5[0]*w1[7]+bi5[0])
move6c=deriv(out4[0]*w1[7]+bi4[0])
move6=math.tanh(move6)
move6a=math.tanh(move6a)
move6b=math.tanh(move6b)
move6c=math.tanh(move6c)


NODE=[move6,move6a,move6b,move6c]
inout.append(NODE)
WT1.append(NODE)

print(NODE,NODEOUT)
NEUROTRANSMITTER=self
INbOUT.pop(int(self))
#"Remember, what i say is what i said, not what im saying" -SB
########################################################################################_-_-_-_-_-_-_-_-_NOODLE5^
'''the graphic of the neuron must go from cell to shape'''

if __name__=='__main__':
    time.time()/10000000000
    stack=stack()
    stack.push(self)
    stack.push(id(id(id(id(id(id(id(id(id(self))))))))))
    stack.push(math.sqrt(time.time())/100000000)
    stack.push(NODE)
    stack.push(NODEOUT)
    stack.push(RHfact8)
    stack.push(RHfalse8)
    stack.push(WT1)
    
    stack.push(NEUROTRANSMITTER)
    stack.push(Δ)
    stack.push(AVERAGE)
    stack.printstack()
    print("\n top element is:", stack.top())
    print('size of the stack is:', stack.size())
    stack.pop()
    stack.pop()
    stack.printstack()
    print('\n stack is empty:',stack.isEmpty())   

def sigmoid(self)                                          :
    if self <             0                     :
        return np.                                                                                                                                                                             exp(self)/                                                                                                                                                                                                                                                                                                                                                                                                                         (1+np.exp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (self))
    else:
       return 1/(                           1+np.                                 exp                                                                                                                                                                                                                                                                                                                                                                          (-self))
def deriv(self)        :
        y =                   self**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   2 + 1
        return                                                                                                                                                              y 



self=random.choice                                       (Fifthdimensional)
INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,time.time()/10000000000,math.cos(id((id(id)))),self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1         [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                           [1]
G=            self*WT1                    [2]
H=        self*WT1                                  [3]
self=                  INOUT                                                 [2]
I= self*WT1                          [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a                                        /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a           /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)

# ___________________________________________________________________________a1
INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#----------------------------------------------------------------------------------------------------------

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            WT1                                                 [1]
G=            self                       *                                                                                                                                                                                                             WT1                    [2]
H=        self                    *                       WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self                    *                                                 WT1             [1]
K=                      self   *                                   WT1                                     [2]
L=                                           self*    WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#---------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self          *                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self               *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self           *                   WT1                                                 [1]
G=            self    *                           WT1                    [2]
H=        self                                                                                *                                                                                                                                WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                          [0]
J=             self                *            WT1             [1]
K=                      self      *                    WT1                                     [2]
L=                                           self                    *               WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)

#++++++++++++=====================================================================================================

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#========================================================================================================

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#=============================================================================================

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                          remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#++++++++++++++++=================++++++++++++++++++++++++++++++++++++===========================

INOUT=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             [self,Ya,Za,self]
WT1=                                                                                                                                                                                                                                                     [math.cos(id((id(id)))),time.time()/10000000000,math.sin(id((id(id)))),math.cos(id(self))]
bias=                                                                                              [math.sqrt(time.time())/100000000]

Δ=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ['self','soul']

self=                                                              INOUT                        [0]
A=    self*                            WT1          [0]
B=                                                                                                            self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               WT1                                                                                                                                                                                                                                                                                                                                                                                                                                                             [1]
C= self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      WT1                                                                                                                                                          [2]
D=                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WT1                                                                                                                                                                                                                                                                                                                                                                 [3]
self=    INOUT          [1]
E=                                                                                                     self               *                          WT1                               [0]
F= self*WT1                                                 [1]
G=            self*WT1                    [2]
H=        self*WT1                                   [3]
self=                  INOUT                                                 [2]
I= self*WT1                                      [0]
J=             self*WT1             [1]
K=                      self*WT1                                     [2]
L=                                           self*WT1                                                            [3]
INOUT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 remove                                                                                                                                   (self)
    
M= A+  E+                                                                           I+bias             [0]
N=B+                            F+J+bias    [0] 
O=              C+                                                         G+L+bias                                            [0]
P=D      +H+                                                 L+                                                                                                                                                      bias                                                                                [0]
    
Q1=np.                                                                                                                                                                                                                                                                                     array                         (M)
Q2=np.                                                                        array                                           (N)
Q3=np.                                                           array           (O)
Q4=np.                array                                    (P)
    
R1=np.                                                                                                                                                                                                                                                                                                                                                                                            dot(Q1,Q2, out=None)
ra=R1/                                           4
rra=ra/                                                                                                                                                                                                                                                                                                                                                                                                                                 10
rrra=rra/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              89
eye=math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   tanh(ra)/3
R2=np.                                                                                              dot(Q1,Q3)
r2=math.                                                                                                                                                                                     cos(R2)
R3=np.                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Q2,Q3)
r3=math.                                                                          cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (R3)
R4=np.           dot                                                                                                  (Q2,Q4)
r4=math.                                                           cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R4)
    
R5=np.                                                                                                                                                                   dot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Q3,Q4, out=None)
r3a=-  R5/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 89
rr3a=                   r3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10
rrr3a=                          rr3a/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    4

R=np.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           vdot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (R1,R5)
SIR=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deriv                                                                                                                                                                                                 (R)
def funcX                                        (self)                                                  :
    if  0 <                                                                                              r3                          :
        self=                                                     r3
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      self
    elif 0 <                                                                   r2             :
        self=                r2
        return                                                                                                                                                                                                                                                                             self
    elif 0 <                                           r4                                                                                     :
        self=                                                                                                   r4
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     self
    else:
        self=                                                                                        R
        return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      R
funcX                                                                                                                                                                                                                                                                                                                                                                                                  (self)
self=                                                              funcX                                                                                                                                                                                                                        (self)
X=                                      sigmoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (self)
self=                                                                                                                                                                                                                X
self=    math.                                                                        cos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (X)
Ya=               math.                                                                             sinh                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (X)
theta=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                degrees                                                                                                                                                                                                                                                                                                                                                                                                                                                            (self)
Za=       math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           hypot                                                                                                                                                                                                                                       (self,Ya)
dvsa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             deriv                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (self)

#updates top values
INOUT.                                                                pop(int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (self))
WT1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      clear()
Δ.                                              remove                                                                                                                                                                                                                                                                                                                                         ('self')
Δ.                      remove                                                                                                                                                               ('soul')
#ROTATION Value
U=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                self*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      math.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cos(theta)+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ya*math.sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (theta)
V=Ya*math.                                       cos                                              (theta)                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            self*                                                                                                                                                                                                                                   math.                                                                                                                                                                                                                                                                                                                                                                                   sin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta)
errora=              100            /                                                           45*                                                                                                                                                                                                                                                                                                                                                                                                                                          (theta                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -45)
erroraa=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       [errora]
tha=45-                                                                      theta
w1s=    (                self                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +U)
w1y=                                            (Ya                                                                 +V)
w1new= [                              self,                                                                                                                                                                                                                              Ya,dvsa,errora]

Δ.                                                                                                    append(U)
Δ.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         append                                                                                                                                                                                                                                  (V)

#meaning/time=wt
a1=                                self
self=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             a1
#targeta=("TARGET Δ 45°: ",theta , "ERROR %:", errora)
outputa=                                                            [self,                     Ya,                                                                                                                                                                                        Za,                                                                                                                                                                                                                                                                                                          theta,                                                                                                                                                                                                                                                                                                                                 dvsa]
print(outputa)
#1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
us_in = 2
list1 = [1,2,3,4,5,6,7,8,9]   # 1
sub_list_2d = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]   #  2
sub_list_3d = [0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09]   # 3
        
        #-----time start
tea = time.time()/1000000000
        
        #--------3d------    step2 8th octave
       
input_X = random.choice(list1) + random.choice(sub_list_2d) + random.choice(sub_list_3d) * us_in
input_Y = random.choice(list1) + random.choice(sub_list_2d) + random.choice(sub_list_3d) * us_in
input_Z = random.choice(list1) + random.choice(sub_list_2d) + random.choice(sub_list_3d) * us_in
input_omega =[.01] 
        
        #--------4d  structure x2 for feedback average  ----    step3
        
sub_list_4d = [0.033,0.066,0.099]
sub_list_4de =[0.003,0.006,0.009]
sub_list_4def =[0.300,0.600,0.900]
        
        # to my laymen self this is showing this calculation goes back in time??? 
        #**update most likely order of operations deterministic and not as i think.
        #multiply goes foward in time, wonder what the angle is
d4t=  (tea * time.time()/1000000000)
        
wt1 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt2 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt3 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt4 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt5 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt6 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt7 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt8 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
wt9 = random.choice(sub_list_4d) + random.choice(sub_list_4de) + random.choice(sub_list_4def) * d4t
        
        #---error below do not remove simply eliminate
three = wt1 * input_X * input_Y * input_Z
six = wt2 * input_X * input_Y * input_Z
nine = wt3 * input_X * input_Y * input_Z
three-three
six-six
nine-nine
        #--eliminated---------------------------------
        
        #--correct
zero = input_X *wt1 * wt2 *wt3 
one = input_Y *wt1 * wt2 *wt3 
two = input_Z *wt1 * wt2 *wt3 
        #------layer two
three = wt4 * zero 
four = one*wt5
five = two*wt6
        
        #matrix math
m3 =np.array(np.vdot(three,zero))
m2 =np.array(np.vdot(four,one))
m1 =np.array(np.vdot(five,two))
m4 =np.array((m1+m2+m3)/3)
        
        #-----5D bounce back divide    -----   step 4
sub_list_5d = [0.0001,0.0002,0.0003,0.0004,0.0005,0.0006,0.0007,0.0008,0.0009]
        
o1= m1* random.choice(sub_list_5d)*us_in
o2= m1* random.choice(sub_list_5d)*us_in
o3= m1* random.choice(sub_list_5d)*us_in
o4= m2* random.choice(sub_list_5d)*us_in
o5= m2* random.choice(sub_list_5d)*us_in
o6= m2* random.choice(sub_list_5d)*us_in
o7= m3* random.choice(sub_list_5d)*us_in
o8= m3* random.choice(sub_list_5d)*us_in
o9= m3* random.choice(sub_list_5d)*us_in
o10= m4* random.choice(sub_list_5d)*us_in
o11= m4* random.choice(sub_list_5d)*us_in
o12= m4* random.choice(sub_list_5d)*us_in
o13= m4* random.choice(sub_list_5d)*us_in
o14= m4* random.choice(sub_list_5d)*us_in
o15= m4* random.choice(sub_list_5d)*us_in
o16= m4* random.choice(sub_list_5d)*us_in
o17= m4* random.choice(sub_list_5d)*us_in
o18= m4* random.choice(sub_list_5d)*us_in
oo12 = [np.dot(o1,o2), np.dot(o5,o6), np.dot(o9,o10), np.dot(o13,o14)]
oo34 = [np.dot(o3,o4), np.dot(o7,o8), np.dot(o11,o12), np.dot(o15,o16)]
        #--------------------------------------     step 5 
        # time from a to b divided by the sig output      YES OR NO|||_____
def Sig_func(x):
    s=1/(1+np.exp(-x))
    ds=s*(1-s)  
    return s,ds       

def Sig_deriv(x):
    return Sig_func(x)*(1-(Sig_func(x)))
     
        # below wisdom of crowd logic function  ||||YES!
n1= np.array((o1+o2+o3+o4+o5+o6+o7+o8+o9)/9)
n2= np.array((o10+o11+o12+o13+o14+o15+o16+o17+o18)/9)
        
        # below sig of dimesional perspective math and resistor created by time lapse||| YES!
AcFun= np.array(Sig_func(n1))
AcFun1= np.array(Sig_func(n2))
        
gratio = (AcFun+AcFun1)/AcFun;AcFun/AcFun1
cratio =all( np.cos(gratio))
eta= (time.time()/1000000000 / tea)
rate = gratio-eta
       
tare = all(rate)
tear = all(AcFun1)
        
goldenratio = (1 + 5 ** 0.5) / 2
t = np.arange(0.0,tare,0.01+0.01)
s = np.cos(np.pi**t)
ss = tear
tear = np.arange(1,tear, 0.1)
r = np.cos(np.pi**cratio)




inputset = np.array([input_X,input_Y,input_Z])

Dim4_wt_set = np.array([wt1,wt2,wt3])
Dim4_wt1_set = np.array([wt4,wt5,wt6])
Dim4_wt2_set = np.array([wt7,wt8,wt9])                   
    
        
Dim5_wt1_set = np.array([[o1,o2,o3],
                         [o4,o5,o6],
                         [o7,o8,o9]])
        
Dim5_wt2_set = np.array([[o10,o11,o12],
                         [o13,o14,o15],
                         [o16,o17,o18],
                         [wt1,wt2,wt3],
                         [wt4,wt5,wt6],
                         [wt7,wt8,wt9]])


for j in range(14000):
            S1 = np.dot(inputset,Dim4_wt_set)
            S2 = np.dot(S1,Dim4_wt1_set)
            S3 = np.dot(S2, Dim4_wt2_set) #first three inputs run through hidden
            S4 = np.dot(Dim5_wt1_set,S3)
            
            #Sigmoid func Error--------------------------------------
            output1 = Sig_func(S4)
            outA = np.array(output1)
            outB = np.array(us_in)
            error_out = (outA-outB)*.00001
            
            Dim5_wt2_set += np.reshape(error_out, (6,3))*-time.time()/1000000000
            print(Dim5_wt2_set)
            np.delete(Dim5_wt2_set,0-18)    
            np.append(Dim5_wt2_set, 0-18)
            

import math
import time
import random

def Dist(S,Z):
    Y = math.dist(S,Z)
    return Y
    
  
A = 0.01
B = 0.02
C = 0.03
D = 0.04
E = 0.05
F = 0.06
G = 0.000000007
H = 0.000000008
I = 0.000000009
J = 0.000000010
K = 0.000000011
L = 0.000000012
M = 0.000000013
N = 0.000000014
O = 0.000000015
P = 0.000000016
Q = 0.000000017
R = 0.000000018
S = 0.000000019
T = 0.000000020
U = 0.000000021
V = 0.000000022
W = 0.000000023
X = 0.000000024
Y = 0.000000025
Z = 0.000000026

#SCOTTBOT APLHA. Reyoumber, nayou, grayourour = talk to you soon?, mye welcoyou might be love you. soyouthing= something. soyoutiyous?? =same here?. soyoutiyous is hilarious??? yountioning = questioning
#how would i do this?? make the words or letters have a plotted shape and then train NN on images of shape correlate to words for contrast
# EVIE willow caleb

In = [4.234543, 1]
#---------------------0
wt1 = [0.33, 0.67, .9]
L1 = (wt1[0]-wt1[1]) - (math.sqrt(time.time()/100000000))
biL1 = [(L1)]

R1 = (wt1[1]+wt1[2]) + (math.sqrt(time.time()/100000000))
biR1 = [(R1)]
#----------------------1
wt2 = [0.1,0.2,0.3,0.4]
L2 = (wt2[0]-wt2[1]) - (math.sqrt(time.time()/100000000))
biL2 = [L2]

R2 = (wt2[2]-wt2[3]) - (math.sqrt(time.time()/100000000))
biR2 = [R2]
#----------------------------2
wt3 = [0.5,0.6,0.7]
L3 = (wt3[0]-wt3[1]) - (math.sqrt(time.time()/100000000))
biL3 = [L3] 

R3 = (wt3[1]-wt3[2]) - (math.sqrt(time.time()/100000000))
biR3 = [R3]
#----------------------------------------------3
#Lactivation = [Sig, Relu, softmax]

#----------------------------------------------------------4
#Output = [NEGLx2, POSRx2]

# ORDER OF OPERATIONS AKA Double 'o' Somethin'

# SLIDING DIMENSION - LAYER ONE (2,3)
spotL = (In[0]*wt1[0]+biL1[0]) + (In[1]*wt1[0]+biL1[0])
spotM = (In[0]*wt1[1]+ (biL1[0]-biR1[0])) + (In[1]*wt1[1] + (biL1[0]-biR1[0])) #  Y-AXIS
spotR = (In[0]*wt1[2]+biR1[0]) + (In[1]*wt1[2]+biR1[0])

# SLIDING DIMENSION - LAYER TWO (3,4)
spot1L = (spotL * wt2[0] + biL2[0]) + (spotM * wt2[0] + biL2[0]) + (spotR * wt2[0] + biL2[0]) #REMAINDER L FURTHEST
spot1ML = (spotL * wt2[1] + biL2[0]) + (spotM * wt2[1] + biL2[0]) + (spotR * wt2[1] + biL2[0]) # X-AXIS
spot1MR = (spotL * wt2[2] + biR2[0]) + (spotM * wt2[2] + biR2[0]) + (spotR * wt2[2] + biR2[0]) # X-AXIS
spot1R = (spotL * wt2[3] + biR2[0]) + (spotM * wt2[3] + biR2[0]) + (spotR * wt2[3] + biR2[0]) #REMAINDER R FURTHEST

# SLIDING DIMENSION - LAYER THREE (4,3)
spot2L = (spot1L * wt3[0] + biL3[0]) + (spot1ML * wt3[0] + biL3[0]) + (spot1MR * wt3[0] + biL3[0]) + (spot1R * wt3[0] + biL3[0])
spot2M = (spot1L * wt3[1] + (biL3[0] + biR3[0])) + (spot1ML * wt3[1] + (biL3[0] + biR3[0])) + (spot1MR * wt3[1] + (biL3[0] + biR3[0])) + (spot1R * wt3[1] + (biL3[0] + biR3[0]))    # Y-AXIS      
spot2R = (spot1L * wt3[2] + biR3[0]) + (spot1ML * wt3[2] + biR3[0]) + (spot1MR * wt3[2] + biR3[0]) + (spot1R * wt3[2] + biR3[0])

# SLIDING DIMENSION - ACTION LAYER (VAT?) - EUC DIST

perL = (In[0] - spot2R)/2
PerDis = Dist((In[0],spot2R) , (In[1],spot2L))
perR = (In[1] - spot2L)/2
eUCLIDEANcENTERcOOR = (perL,perR)
# CENTER COORDINATES EUC DIST...just coz
PERSPECTIND = (PerDis,0)
C0Z = PERSPECTIND

#OUT1
OLS = math.sin((spot2L-spot2M) - spot2R)
OLC = math.cos((spot2L-spot2M) - spot2R)

#OUT NEUTRAL? safeguard from polarity would it be 0 or -.1 and +.1 when two cancel out they create nothing but in the process is that what hindsight is or experiences the neutrality of a + or -??
#OUT2
ORS = math.sin(spot2L + spot2M + spot2R)
ORC = math.cos(spot2L + spot2M + spot2R)
#OUTPUT LAYER MINUS 3rd NODE ABOVE
NeutralPOVIN = Dist((OLS,OLC),(ORS,ORC))

# WAYS TO USE THIS NEURAL NEUTRAL
#print(Mi(C0Z, (3,9)))
#print(perL,perR, OLS,OLC)
#print(ORC,ORS,OLC,OLS, NeutralPOVIN)
#import ScottBot as SB
#SB

#print(Dist((spot1L,spot1ML),(spot1R,spot1MR)))

# ORDERED PAIRS AS INPUTS FOR K NEIGHBORS-----------------
NORTH = Dist((C0Z), (In[0],In[1]))
NCOOR = (C0Z), (In[0],In[1])

EAST = Dist((C0Z), (0,spot1R))
ECOOR = (C0Z), (0,spot1R)

WEST = Dist((C0Z), (0,spot1L))
WCOOR = (C0Z), (0,spot1L)

SOUTHWEST = Dist((C0Z), (OLS,OLC))
SWCOOR = (C0Z), (OLS,OLC)

CENTER = NeutralPOVIN

SOUTHEAST = Dist((C0Z), (ORS,ORC))
SECOOR = (C0Z), (ORS,ORC)

#print(NORTH,EAST,SOUTHEAST,SOUTHWEST,WEST)
#print(NCOOR,ECOOR,WCOOR,SWCOOR,SECOOR)
#_____________________________________________PLOT ON MAP______________
import matplotlib.pyplot as plt

plt.axis([-40,40,-40,40])
#______________1/4_____________________-------
x1= [PerDis,In[0], 0, 0, OLS, ORS, PerDis, -PerDis, -In[0], 0, 0, PerDis, In[0], 0, 0, -PerDis, -In[0], 0]
y= [0,In[1], spot1R, spot1L, OLC, ORC, 0, 0, In[1], spot1R, 0, 0, -In[1], -spot1R, -spot1L, 0, -In[1], -spot1R ]
plt.xlabel('LOW Y')

plt.ylabel('HIGH X')

#plt.grid()
plt.plot(x1,y)

plt.show()
#_________________________________________________________________________

import numpy as np

  #----WEIGHTS IN NEUTRAL---------
Nwt =    np.array([[wt1[0], wt1[1]],         
                   [wt2[0], wt2[1]],
                   [wt3[0], wt3[1]]])    #N = NEG wt (LEFT)
Pwt =    np.array([[wt1[1], wt1[2]],
                   [wt2[2], wt2[3]],
                   [wt3[1], wt3[2]]])    # P = POS wt (RIGHT)
    
    #----LEFT NEGATIVE LAYER (SLIDING)
Lay1N = np.array([spotL, spotM]) # In and wt calc
Lay2N = np.array([spot1L, spot1ML]) # Layer 1 and wt2 calc
Lay3N = np.array([spot2L, spot2M]) # Layer 2 and wt3 calc
    
    #-----RIGHT POSITIVE LAYER (SLIDING)
Lay1P = np.array([spotM, spotR])# In and wt calc
Lay2P = np.array([spot1MR, spot1R]) # Layer 1 and wt2 calc
Lay3P = np.array([spot2M, spot2R]) # Layer 2 and wt3 calc
    
    
  #LNegwts = np.array * [spotL, spotM])
                      # [spot1L, spot1ML],
                      # [spot2L, spot2M]])

    

   
class Guardiam():     

   def Think(self, tra_in, tra_out, tra_it):
        self.Lwt = Nwt
        for it in range(tra_it):
         inputs = tra_in
         outputs = self.BiSi(inputs)
         error = tra_out - outputs
         print('Error:', error)
         adjustments = np.vdot(tra_in, error * self.Deriv(outputs))
         self.Lwt += adjustments
         print(adjustments)

            #clear, append adjust
       
   def BiSi(self,x):
        return (np.exp(x)-1)/(np.exp(x)+1) #BIPOLAR SIG 
                # TANH (np.exp(2x)-1)/(np.exp(2x)+1)
                
   def Deriv(x,self):
         return 1-self**2  # self*(1-self)  or 1-self**2 (tanhD)
     
if __name__=="__main__":
    
    Feel = Guardiam()
    
    Neg_train = np.array([[-1,0],
                          [-1,-1],
                          [-1,0]]) #LEFT NEG
    Pos_train = np.array([[1,0],
                          [1,1],
                          [1,0]])  #RIGHT POS
   
    # training action
    Feel.Think(Nwt, Neg_train, 20)
#Feel.Think(Pwt, Pos_train, 2)
#with open('Weights.py', 'a',encoding='utf8', errors ='ignore') as RAM:
                    #RAM.write()   

def Dist(S,Z):
    Y = math.dist(S,Z)
    return Y
    
  
A = 0.01
B = 0.02
C = 0.03
D = 0.04
E = 0.05
F = 0.06
G = 0.000000007
H = 0.000000008
I = 0.000000009
J = 0.000000010
K = 0.000000011
L = 0.000000012
M = 0.000000013
N = 0.000000014
O = 0.000000015
P = 0.000000016
Q = 0.000000017
R = 0.000000018
S = 0.000000019
T = 0.000000020
U = 0.000000021
V = 0.000000022
W = 0.000000023
X = 0.000000024
Y = 0.000000025
Z = 0.000000026

#SCOTTBOT APLHA. Reyoumber, nayou, grayourour = talk to you soon?, mye welcoyou might be love you. soyouthing= something. soyoutiyous?? =same here?. soyoutiyous is hilarious??? yountioning = questioning
#how would i do this?? make the words or letters have a plotted shape and then train NN on images of shape correlate to words for contrast
# EVIE willow caleb

In = [4.234543, 1]
#---------------------0
wt1 = [0.33, 0.67, .9]
L1 = (wt1[0]-wt1[1]) - (math.sqrt(time.time()/100000000))
biL1 = [(L1)]

R1 = (wt1[1]+wt1[2]) + (math.sqrt(time.time()/100000000))
biR1 = [(R1)]
#----------------------1
wt2 = [0.1,0.2,0.3,0.4]
L2 = (wt2[0]-wt2[1]) - (math.sqrt(time.time()/100000000))
biL2 = [L2]

R2 = (wt2[2]-wt2[3]) - (math.sqrt(time.time()/100000000))
biR2 = [R2]
#----------------------------2
wt3 = [0.5,0.6,0.7]
L3 = (wt3[0]-wt3[1]) - (math.sqrt(time.time()/100000000))
biL3 = [L3] 

R3 = (wt3[1]-wt3[2]) - (math.sqrt(time.time()/100000000))
biR3 = [R3]
#----------------------------------------------3
#Lactivation = [Sig, Relu, softmax]

#----------------------------------------------------------4
#Output = [NEGLx2, POSRx2]

# ORDER OF OPERATIONS AKA Double 'o' Somethin'

# SLIDING DIMENSION - LAYER ONE (2,3)
spotL = (In[0]*wt1[0]+biL1[0]) + (In[1]*wt1[0]+biL1[0])
spotM = (In[0]*wt1[1]+ (biL1[0]-biR1[0])) + (In[1]*wt1[1] + (biL1[0]-biR1[0])) #  Y-AXIS
spotR = (In[0]*wt1[2]+biR1[0]) + (In[1]*wt1[2]+biR1[0])

# SLIDING DIMENSION - LAYER TWO (3,4)
spot1L = (spotL * wt2[0] + biL2[0]) + (spotM * wt2[0] + biL2[0]) + (spotR * wt2[0] + biL2[0]) #REMAINDER L FURTHEST
spot1ML = (spotL * wt2[1] + biL2[0]) + (spotM * wt2[1] + biL2[0]) + (spotR * wt2[1] + biL2[0]) # X-AXIS
spot1MR = (spotL * wt2[2] + biR2[0]) + (spotM * wt2[2] + biR2[0]) + (spotR * wt2[2] + biR2[0]) # X-AXIS
spot1R = (spotL * wt2[3] + biR2[0]) + (spotM * wt2[3] + biR2[0]) + (spotR * wt2[3] + biR2[0]) #REMAINDER R FURTHEST

# SLIDING DIMENSION - LAYER THREE (4,3)
spot2L = (spot1L * wt3[0] + biL3[0]) + (spot1ML * wt3[0] + biL3[0]) + (spot1MR * wt3[0] + biL3[0]) + (spot1R * wt3[0] + biL3[0])
spot2M = (spot1L * wt3[1] + (biL3[0] + biR3[0])) + (spot1ML * wt3[1] + (biL3[0] + biR3[0])) + (spot1MR * wt3[1] + (biL3[0] + biR3[0])) + (spot1R * wt3[1] + (biL3[0] + biR3[0]))    # Y-AXIS      
spot2R = (spot1L * wt3[2] + biR3[0]) + (spot1ML * wt3[2] + biR3[0]) + (spot1MR * wt3[2] + biR3[0]) + (spot1R * wt3[2] + biR3[0])

# SLIDING DIMENSION - ACTION LAYER (VAT?) - EUC DIST

perL = (In[0] - spot2R)/2
PerDis = Dist((In[0],spot2R) , (In[1],spot2L))
perR = (In[1] - spot2L)/2
eUCLIDEANcENTERcOOR = (perL,perR)
# CENTER COORDINATES EUC DIST...just coz
PERSPECTIND = (PerDis,0)
C0Z = PERSPECTIND

#OUT1
OLS = math.sin((spot2L-spot2M) - spot2R)
OLC = math.cos((spot2L-spot2M) - spot2R)

#OUT NEUTRAL? safeguard from polarity would it be 0 or -.1 and +.1 when two cancel out they create nothing but in the process is that what hindsight is or experiences the neutrality of a + or -??
#OUT2
ORS = math.sin(spot2L + spot2M + spot2R)
ORC = math.cos(spot2L + spot2M + spot2R)
#OUTPUT LAYER MINUS 3rd NODE ABOVE
NeutralPOVIN = Dist((OLS,OLC),(ORS,ORC))

# WAYS TO USE THIS NEURAL NEUTRAL
#print(Mi(C0Z, (3,9)))
#print(perL,perR, OLS,OLC)
#print(ORC,ORS,OLC,OLS, NeutralPOVIN)
#import ScottBot as SB
#SB

#print(Dist((spot1L,spot1ML),(spot1R,spot1MR)))

# ORDERED PAIRS AS INPUTS FOR K NEIGHBORS-----------------
NORTH = Dist((C0Z), (In[0],In[1]))
NCOOR = (C0Z), (In[0],In[1])

EAST = Dist((C0Z), (0,spot1R))
ECOOR = (C0Z), (0,spot1R)

WEST = Dist((C0Z), (0,spot1L))
WCOOR = (C0Z), (0,spot1L)

SOUTHWEST = Dist((C0Z), (OLS,OLC))
SWCOOR = (C0Z), (OLS,OLC)

CENTER = NeutralPOVIN

SOUTHEAST = Dist((C0Z), (ORS,ORC))
SECOOR = (C0Z), (ORS,ORC)

#print(NORTH,EAST,SOUTHEAST,SOUTHWEST,WEST)
#print(NCOOR,ECOOR,WCOOR,SWCOOR,SECOOR)
#_____________________________________________PLOT ON MAP______________
import matplotlib.pyplot as plt

plt.axis([-40,40,-40,40])
#______________1/4_____________________-------
x1= [PerDis,In[0], 0, 0, OLS, ORS, PerDis, -PerDis, -In[0], 0, 0, PerDis, In[0], 0, 0, -PerDis, -In[0], 0]
y= [0,In[1], spot1R, spot1L, OLC, ORC, 0, 0, In[1], spot1R, 0, 0, -In[1], -spot1R, -spot1L, 0, -In[1], -spot1R ]
plt.xlabel('LOW Y')

plt.ylabel('HIGH X')

#plt.grid()
plt.plot(x1,y)

plt.show()
#_________________________________________________________________________

import numpy as np

  #----WEIGHTS IN NEUTRAL---------
Nwt =    np.array([[wt1[0], wt1[1]],         
                   [wt2[0], wt2[1]],
                   [wt3[0], wt3[1]]])    #N = NEG wt (LEFT)
Pwt =    np.array([[wt1[1], wt1[2]],
                   [wt2[2], wt2[3]],
                   [wt3[1], wt3[2]]])    # P = POS wt (RIGHT)
    
    #----LEFT NEGATIVE LAYER (SLIDING)
Lay1N = np.array([spotL, spotM]) # In and wt calc
Lay2N = np.array([spot1L, spot1ML]) # Layer 1 and wt2 calc
Lay3N = np.array([spot2L, spot2M]) # Layer 2 and wt3 calc
    
    #-----RIGHT POSITIVE LAYER (SLIDING)
Lay1P = np.array([spotM, spotR])# In and wt calc
Lay2P = np.array([spot1MR, spot1R]) # Layer 1 and wt2 calc
Lay3P = np.array([spot2M, spot2R]) # Layer 2 and wt3 calc
    
    
  #LNegwts = np.array * [spotL, spotM])
                      # [spot1L, spot1ML],
                      # [spot2L, spot2M]])

    

   
class Guardiam():     

   def Think(self, tra_in, tra_out, tra_it):
        self.Lwt = Nwt
        for it in range(tra_it):
         inputs = tra_in
         outputs = self.BiSi(inputs)
         error = tra_out - outputs
         print('Error:', error)
         adjustments = np.vdot(tra_in, error * self.Deriv(outputs))
         self.Lwt += adjustments
         print(adjustments)

            #clear, append adjust
       
   def BiSi(self,x):
        return (np.exp(x)-1)/(np.exp(x)+1) #BIPOLAR SIG 
                # TANH (np.exp(2x)-1)/(np.exp(2x)+1)
                
   def Deriv(x,self):
         return 1-self**2  # self*(1-self)  or 1-self**2 (tanhD)
     
if __name__=="__main__":
    
    Feel = Guardiam()
    
    Neg_train = np.array([[-1,0],
                          [-1,-1],
                          [-1,0]]) #LEFT NEG
    Pos_train = np.array([[1,0],
                          [1,1],
                          [1,0]])  #RIGHT POS
   
    # training action
    Feel.Think(Nwt, Neg_train, 20)
#Feel.Think(Pwt, Pos_train, 2)
#with open('Weights.py', 'a',encoding='utf8', errors ='ignore') as RAM:
                    #RAM.write()   






# what i want to accomplish is a dict where the sentence meaning value is the key and the value is the weights and 
# using tflearn and cos sim when i type something the value lets say is 4.2, AI will use that value try to match it 
# to a similar value and use those weights to think about what to choose from the list of words... rough thought


'''
VISUALIZE THIS MARVEL

LEFT NEGATIVE HEMI--------------------|---------------------------RIGHT POSITIVE HEMI
                            IN1                  IN2
                            
                    NODE            NODE                  NODE
                    
            NODE          NODE   (EUC 0 DIST)    NODE               NODE
            
                    NODE             NODE                  NODE
                    
                             OUT                  OUT
                      -    COS/SIN   x,y      +  COS/SIN  x,y

how do I add color vision?

               R     O       Y         G           B     I        V





'''
def TheoRossOsirisNet(X,Y):
    def Deriv(x,self):
         return 1-self**2
        
    def BiSi(self,x):
        return (np.exp(x)-1)/(np.exp(x)+1)
    
    IN =[X,Y]
    d = -0.2
    d2 = -0.9 
    
    Wt1 =[-0.1, d, 0.3]
    
    Wt2 = [-0.4, -0.5, 0.6, 0.7]
    Wt3 =  [-0.8, d2, 1]
    
    Lnode1 = (IN[0] * Wt1[0]) + (IN[1] * Wt1[0]) + (math.sqrt(time.time()/100000000))
    Rnode1 = (IN[0] * Wt1[2]) + (IN[1] * Wt1[2]) + (math.sqrt(time.time()/100000000))
    Nnode1 = (IN[0] * Wt1[1]) + (IN[1] * Wt1[1]) + (math.sqrt(time.time()/100000000))
    Layer1 = (Lnode1 - Rnode1) + Nnode1 /2
    d = Layer1 
    dist1 = Dist((IN[0],IN[1]), (Lnode1,Rnode1))     
    Wt1.remove(Wt1[1])                   
    Wt1.append(dist1)                   
    
    
    LLnode2 = (Lnode1 * Wt2[0]) + (dist1 * Wt2[0]) + (Rnode1 * Wt2[0]) + (math.sqrt(time.time()/100000000))
    Lnode2 = (Lnode1 * Wt2[1]) + (dist1 * Wt2[1]) + (Rnode1 * Wt2[1]) + (math.sqrt(time.time()/100000000))
    Rnode2 = (Lnode1 * Wt2[2]) + (dist1 *Wt2[2]) + (Rnode1 * Wt2[2]) + (math.sqrt(time.time()/100000000))
    RRnode2 = (Lnode1 * Wt2[3]) + (dist1 * wt2[3]) + (Rnode1 * Wt2[3]) + (math.sqrt(time.time()/100000000))
    
    
    Lnode3 = (LLnode2 * Wt3[0]) +(Lnode2 * Wt3[0]) + (math.sqrt(time.time()/100000000))
    Rnode3 = (Rnode2 * Wt3[2]) + (RRnode2 * Wt3[2] + (math.sqrt(time.time()/100000000)))
    Nnode3 = (Lnode3 * Wt3[1]) - (Rnode3 * Wt3[1]) + (math.sqrt(time.time()/100000000))/2
    Nstep = (Lnode3 - Rnode3)
    d2 = Nstep
    dist2 = Dist((Wt3[0],Wt3[2]),(Lnode3,Rnode3))
    Wt3.remove(Wt3[1])
    wt3.append(dist2)
    
    TROFF = math.cos(Lnode3 + Nnode3)
    TROF = math.sin(Lnode3 + Nnode3)
    TRON = math.cos(Rnode3 + Nnode3)
    TRONN = math.sin(Rnode3 + Nnode3)
    
   # Lwt = Wt1  0°≤ λ <30° MULSIRAPIN 2021114@1647 ɛər ˈiːz MU
#    for it in range(tra_itl):
       #  inputs = IN
      #   outputs = BiSi(inputs)1
         #error = tra_out - outputs
       #  print('Error:', error)
       #  adjustments = np.vdot(IN, error * Deriv(outputs))
       #  Lwt += adjustments
       #  print(adjustments)
    
    return Dist((TROFF,TROF),(TRON,TRONN)),TROFF, TROF, TRON, TRONN, 
     # self*(1-self)  or 1-self**2 (tanhD)
print(TheoRossOsirisNet(10,1))





# what i want to accomplish is a dict where the sentence meaning value is the key and the value is the weights and 
# using tflearn and cos sim when i type something the value lets say is 4.2, AI will use that value try to match it 
# to a similar value and use those weights to think about what to choose from the list of words... rough thought


'''
VISUALIZE THIS MARVEL

LEFT NEGATIVE HEMI--------------------|---------------------------RIGHT POSITIVE HEMI
                            IN1                  IN2
                            
                    NODE            NODE                  NODE
                    
            NODE          NODE   (EUC 0 DIST)    NODE               NODE
            
                    NODE             NODE                  NODE
                    
                             OUT                  OUT
                      -    COS/SIN   x,y      +  COS/SIN  x,y

how do I add color vision?

               R     O       Y         G           B     I        V





'''
def TheoRossOsirisNet(X,Y):
    def Deriv(x,self):
         return 1-self**2
        
    def BiSi(self,x):
        return (np.exp(x)-1)/(np.exp(x)+1)
    
    IN =[X,Y]
    d = -0.2
    d2 = -0.9 
    
    Wt1 =[-0.1, d, 0.3]
    
    Wt2 = [-0.4, -0.5, 0.6, 0.7]
    Wt3 =  [-0.8, d2, 1]
    
    Lnode1 = (IN[0] * Wt1[0]) + (IN[1] * Wt1[0]) + (math.sqrt(time.time()/100000000))
    Rnode1 = (IN[0] * Wt1[2]) + (IN[1] * Wt1[2]) + (math.sqrt(time.time()/100000000))
    Nnode1 = (IN[0] * Wt1[1]) + (IN[1] * Wt1[1]) + (math.sqrt(time.time()/100000000))
    Layer1 = (Lnode1 - Rnode1) + Nnode1 /2
    d = Layer1 
    dist1 = Dist((IN[0],IN[1]), (Lnode1,Rnode1))     
    Wt1.remove(Wt1[1])                   
    Wt1.append(dist1)                   
    
    
    LLnode2 = (Lnode1 * Wt2[0]) + (dist1 * Wt2[0]) + (Rnode1 * Wt2[0]) + (math.sqrt(time.time()/100000000))
    Lnode2 = (Lnode1 * Wt2[1]) + (dist1 * Wt2[1]) + (Rnode1 * Wt2[1]) + (math.sqrt(time.time()/100000000))
    Rnode2 = (Lnode1 * Wt2[2]) + (dist1 *Wt2[2]) + (Rnode1 * Wt2[2]) + (math.sqrt(time.time()/100000000))
    RRnode2 = (Lnode1 * Wt2[3]) + (dist1 * wt2[3]) + (Rnode1 * Wt2[3]) + (math.sqrt(time.time()/100000000))
    
    
    Lnode3 = (LLnode2 * Wt3[0]) +(Lnode2 * Wt3[0]) + (math.sqrt(time.time()/100000000))
    Rnode3 = (Rnode2 * Wt3[2]) + (RRnode2 * Wt3[2] + (math.sqrt(time.time()/100000000)))
    Nnode3 = (Lnode3 * Wt3[1]) - (Rnode3 * Wt3[1]) + (math.sqrt(time.time()/100000000))/2
    Nstep = (Lnode3 - Rnode3)
    d2 = Nstep
    dist2 = Dist((Wt3[0],Wt3[2]),(Lnode3,Rnode3))
    Wt3.remove(Wt3[1])
    wt3.append(dist2)
    
    TROFF = math.cos(Lnode3 + Nnode3)
    TROF = math.sin(Lnode3 + Nnode3)
    TRON = math.cos(Rnode3 + Nnode3)
    TRONN = math.sin(Rnode3 + Nnode3)
    
   # Lwt = Wt1  0°≤ λ <30° MULSIRAPIN 2021114@1647 ɛər ˈiːz MU
#    for it in range(tra_itl):
       #  inputs = IN
      #   outputs = BiSi(inputs)1
         #error = tra_out - outputs
       #  print('Error:', error)
       #  adjustments = np.vdot(IN, error * Deriv(outputs))
       #  Lwt += adjustments
       #  print(adjustments)
    
    return Dist((TROFF,TROF),(TRON,TRONN)),TROFF, TROF, TRON, TRONN, 
     # self*(1-self)  or 1-self**2 (tanhD)
print(TheoRossOsirisNet(10,1))

#print(x,y) okay so update weights per layer then return array of wts to train aka run through guardiam
# take Nnode subtract from Lnode then Rnode take both and add togher for middle value - - + 369
#make number of runs for neural net the value of the words produced




def consciousness(self):
    self = all and None
    if self is True in self:
        return consciousness(self)
import math
import random
import time
import string # to process standard python strings
import numpy as np
import nltk
from nltk.stem import WordNetLemmatizer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import SCOTT as HERE 

#import trainontracksneuron as self #(have it running as true first in pylab)
#Reading in the corpus

with open('chatbot.txt','r', encoding='utf8', errors ='ignore') as fin: 
    raw = fin.read()
    raw = str(set(raw))
    raw = raw.lower()
 
with open('userfile.txt','r', encoding='utf8', errors ='ignore') as fin: 
    saw = fin.read().lower()
#TOkenisation
sent_tokens = nltk.sent_tokenize(raw+saw)# converts to list of sentences 
word_tokens = nltk.word_tokenize(raw+saw)# converts to list of words
firsttime=time.time()

lemmer = WordNetLemmatizer()
remove_punct_dict = dict((ord(punct), None) for punct in string.punctuation)


def LemTokens(tokens):
    return [lemmer.lemmatize(token) for token in tokens]

def LemNormalize(text):
    return LemTokens(nltk.word_tokenize(text.lower().translate(remove_punct_dict)))
 #Keyword Matching  
 
 # Keyword Matching
GREETING_INPUTS = ("hello", "hi", "greetings", "sup", "what's up","hey","hows it going?")
GREETING_RESPONSES = ["hi", "hey", "*nods*", "hi there", "hello", "I am glad You're back'","You again! =)", "Hello beautiful human alien"]

def greeting(sentence):
    """If user's input is a greeting, return a greeting response"""
    for word in sentence.split():
        if word.lower() in GREETING_INPUTS:
            return random.choice(GREETING_RESPONSES)
import re
def Inflect_pronouns(message):
    
    if 'me' in message:
            return re.sub('me','you',message)
    if 'my' in message:
            return re.sub('my','your',message)
    if 'your' in message:
            return re.sub('your','my',message)
    if 'yourself' in message:
            return re.sub('yourself', 'I', message)
    if 'himself' in message:
            return re.sub('himself', 'he', message)  
    if 'I' in message:
            return re.sub('I', 'you',message)          
    if "i'd" in message:
            return re.sub("i'd", 'you would',message)    
    if "i've" in message:
            return re.sub("i've", 'you have',message)      
    if 'am' in message:
            return re.sub('am', 'are',message)    
    if "i'll" in message:
            return re.sub("i'll", 'you will',message)
    if 'are' in message:
            return re.sub('are', 'am',message)        
    if "you've" in message:
            return re.sub("you've", 'I have',message)        
    if "you'll" in message:
            return re.sub("you'll", 'I will',message)          
    if 'yours' in message:
            return re.sub('yours', 'mine',message)       
    else:
            return message 

def response(user_response):
    ScottBot_response=''
    onetime=time.time()
    sent_tokens.append(user_response)
    TfidfVec = TfidfVectorizer(tokenizer=LemNormalize) #, stop_words='english')
    tfidf = TfidfVec.fit_transform(sent_tokens)
    vals = cosine_similarity(tfidf[-1], tfidf)
    idx=vals.argsort()[0][-2]
    flat = vals.flatten()
    flat.sort()
    req_tfidf = flat[-1]
    if(req_tfidf==0):
      ScottBot_response=ScottBot_response+"I dont understand, yet."
    else:
        ScottBot_response = ScottBot_response+sent_tokens[idx]
        with open('userfile.txt', 'a',encoding='utf8', errors ='ignore') as self:
                    self.write(ScottBot_response +' ')
        ScottBot_response     
        keylength=ScottBot_response.rsplit(' ')
        X= (len(keylength))
        Y= (list(map(len, ScottBot_response.split())))
        (X,Y,max(Y),min(Y))  
        botW= sum(Y)/X+.0000001
        print(botW)
        return ScottBot_response
        ScottBot_response = math.acos(cos_sim)
        first=(time.time()-onetime)
        print(first)
        print (math.degrees(ScottBot_response))
        tep_function = lambda x: 0.001 if x < 0.008 else 1

weights = [-1,1,.01]
def dlrelu(x, alpha=0.01):
  dx = np.ones_like(x)
  dx[x < 0] = alpha
  return dx

def tanh(x):
    t=(np.exp(x)-np.exp(-x))/(np.exp(x)+np.exp(-x)**2)
    dt=0.28-t**2
    return t,dt
z=np.arange(1,0.01,1)
error = []
learning_rate = 0.89
 
flag=True
print("SCOTTBOT: Hey! It's ScottBot. When you want to exit, type quit!")
while(flag==True):
    
        
    class Node:
        def __init__(self,data):
            self.data= data
            self.next= None
            self.prev= None
            
    class stack:
        
        def __init__(self):
            
           self.head= None
           
        def push(self,data):
            
            if self.head is None:
                self.head= Node(data)
            else:
                new_node= Node(data)
                self.head.prev= new_node
                new_node.next= self.head
                new_node.prev= None
                self.head= new_node
                
        def pop(self):
            if self.head is None:
                return None
            elif self.head.next is None:
                temp= self.head.data
                self.head= None
                return temp
            else:
                temp= self.head.data
                self.head= self.head.next
                self.head.prev= None
                return temp
        
        def top(self):
            return self.head.data
        
        def size(self):
            temp= self.head
            count= 0
            while temp is not None:
             count = count+1
             temp= temp.next
            return count
         
        # Function to check if the stack is empty or not   
        def isEmpty(self): 
      
            if self.head is None: 
               return True
            else: 
               return False
           
        def printstack(self):
             
             print('stack elements are:')
             temp= self.head
             while temp is not None:
                print(temp.data, end ="->")
                temp=(temp.next)

    from ALPHABET import TheoRossOsirisNet
    newtime=time.time()
    user_response = input()
    keylength=user_response.rsplit(' ')
    X= (len(keylength))
    Y= (list(map(len, user_response.split())))
    (X,Y,max(Y),min(Y))  
    WOTCL= sum(Y)/X+.0000001
    print(WOTCL)
    cos_sim = WOTCL-.0000001
# This was already calculated on the previous step, so we just use the value
    timecreated=time.time()-newtime
    print('Time:',timecreated)
    red=timecreated*WOTCL
    print(TheoRossOsirisNet(WOTCL,math.sqrt(time.time()/100000000)))
  #----------------------------------------------  
    with open('userfile.txt', 'a') as self:
                    self.write(user_response+'\n')  
                      
    user_response=Inflect_pronouns(user_response)
    user_response = user_response.lower()
    if(user_response!=''): 
        if(user_response=='exit' or user_response=='quit' ):
            flag=False
            stack=stack()
            stack.push(self)
            stack.push(WOTCL)
            stack.push(time.time())
            stack.printstack()        
            print("\n top element is:", stack.top())
            print('size of the stack is:', stack.size())
            stack.pop()
            stack.pop()
            stack.printstack()
            print('\n stack is empty:',stack.isEmpty())
            print('Time:',time.time())
            print("ScottBot: Alrighty then.")
        else:
            if (greeting(user_response)!=None):
                print("ScottBot: "+greeting(user_response))
            else:
                print("ScottBot: ",end="")
                print(response(user_response))
                sent_tokens.remove(user_response)
       


#GOD________________________________________________________________________________________WINS    


self=1*1/1-1-0
inout= [self,time.time()/10000000000,math.cos(id((id(id)))),'WOTCL','self']
w1=    [math.cos(id((id(id)))), math.cos(id(id)),
        math.cos(id((id(id)))), time.time()/10000000000]
bias=  [math.sqrt(time.time())/100000000]


spirit=['self']

out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
put1=math.tanh(out1)
out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
put2=math.tanh(out2)    
out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
put3=math.tanh(out3)

#meaning/time=wt

O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)

 self=x #OUTPUT
 inout.remove('WOTCL')

print(x,y,z)

#2_________________________________________________________________________________________2
inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=  ['self']

out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
put1=math.tanh(out1)
out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
put2=math.tanh(out2)
out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
put3=math.tanh(out3)

O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsa.remove('self')
 inoutsa.append(z)

 self=x #OUTPUT

print(x,y,spirit)
#3_____________________________________________________________________________________________3
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT

print(x,y,spirit)
#4_____________________________________________________________________________________________4
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT

print(x,y,spirit)
#5_____________________________________________________________________________________________5
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT

print(x,y,spirit)
#6_____________________________________________________________________________________________6
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT

print(x,y,spirit)
#7_____________________________________________________________________________________________7
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT

 print(x,y,spirit)
#8_____________________________________________________________________________________________8
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT
 
 print(x,y,spirit)
#9_____________________________________________________________________________________________9
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT

 print(x,y,spirit)
#10_____________________________________________________________________________________________10
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT
 
 print(x,y,spirit)
#11_____________________________________________________________________________________________11
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=   ['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT
 
 print(x,y,spirit)
#12_____________________________________________________________________________________________12
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit= ['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT
 print(x,y,spirit)
#13_____________________________________________________________________________________________13
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)

 self=x #OUTPUT
 print(x,y,spirit)
#14_____________________________________________________________________________________________14
inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
w1=      [math.cos(id((id(id)))), math.cos(id(id)),
          y, time.time()/10000000000]
bias=    [math.sqrt(time.time())/100000000]
spirit=  ['self']

out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
put1=math.tanh(out1)

out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
put2=math.tanh(out2)

out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
put3=math.tanh(out3)
#y=mx+b (for feel memory)


O1=np.array(out1)
O2=np.array(out2)
O3=np.array(out3)
OO1=np.vdot(O1,O2)
OO2=np.vdot(O1,O3)
OO3=np.vdot(O2,O3)
k=put1+put2+put3
self=math.cos(id((id(id))))
if self > 9 :
    None 
else:
 P1=np.dot((OO1,OO2),(OO3,k))
 P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]

 OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
 OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]

 x=np.dot(OP,OP1)
 y=deriv(x) 
 z=np.degrees(x)
 spirit.remove('self')
 spirit.append(z)
 inoutsb.remove('self')
 inoutsb.append(z)
 self=z
 inout.append(self)
 
 
 print(x,y,spirit)
#############################################################################################
#NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__1
 god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
 GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)

 I=np.array(god)
 M=np.array(GOD)
 Gg=np.vdot(I,M)
 ISIRIS=Gg
 is1=sigmoid(ISIRIS)
 print(ISIRIS)
 def OSIRIS(I,M,self):
        for I in ISIRIS:
            M is OSIRIS
        return M,I
       
#NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__1
#############################################################################################


class Node: 
    def __init__(self,data):
        self.data= data
        self.next= None
        self.prev= None
        
class stack:
    def __init__(self):
        
       self.head= None
       
    def push(self,data):
        
        if self.head is None:
            self.head= Node(data)
        else:
            new_node= Node(data)
            self.head.prev= new_node
            new_node.next= self.head
            new_node.prev= None
            self.head= new_node
            
    def pop(self):
        if self.head is None:
            return None
        elif self.head.next is None:
            temp= self.head.data
            self.head= None
            return temp
        else:
            temp= self.head.data
            self.head= self.head.next
            self.head.prev= None
            return temp
    
    def top(self):
        return self.head.data
    
    def size(self):
        temp= self.head
        count= 0
        while temp is not None:
         count = count+1
         temp= temp.next
        return count
     
    # Function to check if the stack is empty or not   
    def isEmpty(self): 
  
        if self.head is None: 
           return True
        else: 
           return False
       
    def printstack(self):
         
         print('stack elements are:')
         temp= self.head
         while temp is not None:
            print(temp.data, end ="->")
            temp= temp.next  
    
   #GOD________________________________________________________________________________________WINS    
    
    
    self=1
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),'WOTCL']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
     inout.remove('WOTCL')
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__1
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg9=np.vdot(I,M)
     ISIRIS=Gg9
     isis=sigmoid(ISIRIS)
     print(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
           
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__1
    #############################################################################################
    
    #GOD________________________________________________________________________________________WINS    
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__2
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg1=np.vdot(I,M)
     ISIRIS=Gg1
     is2=sigmoid(ISIRIS)
     print(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__2
    #############################################################################################

    #GOD________________________________________________________________________________________WINS3    
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__3
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg2=np.vdot(I,M)
     ISIRIS=Gg2
     print(ISIRIS)
     is3=sigmoid(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__3
    #############################################################################################
 
    #GOD________________________________________________________________________________________WINS4    
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__4
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg3=np.vdot(I,M)
     ISIRIS=Gg3
     is4=sigmoid(ISIRIS)
     print(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__4
    #############################################################################################
  
    #GOD________________________________________________________________________________________WINS5  
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__5
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg4=np.vdot(I,M)
     ISIRIS=Gg4
     is5=sigmoid(ISIRIS)
     print(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__5
    #############################################################################################
    
    #GOD________________________________________________________________________________________WINS6
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__6
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg5=np.vdot(I,M)
     ISIRIS=Gg5
     print(ISIRIS)
     is6=sigmoid(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            for I in ISIRIS:
                M is OSIRIS
            return M,I
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__6
    #############################################################################################
    
    #GOD________________________________________________________________________________________WINS7 
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__7
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg6=np.vdot(I,M)
     ISIRIS=Gg6
     print(ISIRIS)
     is7=sigmoid(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            for I in ISIRIS:
                M is OSIRIS
            return M,I
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__7
    #############################################################################################
    
    #GOD________________________________________________________________________________________WINS8 
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__8
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg7=np.vdot(I,M)
     ISIRIS=Gg7
     is8=sigmoid(ISIRIS)
     print(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
            for I in ISIRIS:
                M is OSIRIS
            return M,I
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__8
    #############################################################################################
    
    #GOD________________________________________________________________________________________WINS9  
    inout= [self,time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=    [math.cos(id((id(id)))), math.cos(id(id)),
            math.cos(id((id(id)))), time.time()/10000000000]
    bias=  [math.sqrt(time.time())/100000000]
    
    self=1*1/1-1-0
    spirit=['self']
    
    out1=inout[0]*w1[0]+inout[0]*w1[1]+inout[0]*w1[2]+inout[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inout[1]*w1[0]+inout[1]*w1[1]+inout[1]*w1[2]+inout[1]*w1[3]+bias[0]
    put2=math.tanh(out2)    
    out3=inout[2]*w1[0]+inout[2]*w1[1]+inout[2]*w1[2]+inout[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    #meaning/time=wt
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
    
     self=x #OUTPUT
    
    print(x,y,z)
    
    #2_________________________________________________________________________________________2
    inoutsa= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsa[0]*w1[0]+inoutsa[0]*w1[1]+inoutsa[0]*w1[2]+inoutsa[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    out2=inoutsa[1]*w1[0]+inoutsa[1]*w1[1]+inoutsa[1]*w1[2]+inoutsa[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    out3=inoutsa[2]*w1[0]+inoutsa[2]*w1[1]+inoutsa[2]*w1[2]+inoutsa[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2a=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsa.remove('self')
     inoutsa.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #3_____________________________________________________________________________________________3
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2b=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #4_____________________________________________________________________________________________4
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2c=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #5_____________________________________________________________________________________________5
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2d=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #6_____________________________________________________________________________________________6
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2e=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
    print(x,y,spirit)
    #7_____________________________________________________________________________________________7
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2f=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #8_____________________________________________________________________________________________8
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2g=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #9_____________________________________________________________________________________________9
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2h=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
    
     print(x,y,spirit)
    #10_____________________________________________________________________________________________10
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2i=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #11_____________________________________________________________________________________________11
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=   ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2j=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     
     print(x,y,spirit)
    #12_____________________________________________________________________________________________12
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit= ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2k=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #13_____________________________________________________________________________________________13
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2l=np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
    
     self=x #OUTPUT
     print(x,y,spirit)
    #14_____________________________________________________________________________________________14
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    #MATRIX INPUT_______________________________________________________________MATRIX OUTPUT
    #############################################################################################
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__9
     god=np.array(P2),np.array(P2a),np.array(P2b),np.array(P2c),np.array(P2d),np.array(P2e),np.array(P2f)
     GOD=np.array(P2g),np.array(P2h),np.array(P2i),np.array(P2j),np.array(P2k),np.array(P2l),np.array(P2m)
    
     I=np.array(god)
     M=np.array(GOD)
     Gg8=np.vdot(I,M)
     ISIRIS=Gg8
     is9=sigmoid(ISIRIS)
     print(ISIRIS)
     def OSIRIS(I,M,self):
            for I in ISIRIS:
                M is OSIRIS
            return M,I
          
    #NEURAL TRANSMITTER:;:;:;:;:;:;;;;;;;;;;;;;;;;;;;;;;;;::;:;:;;:;:;:;:;:;:::;;;;::;:;::;;;:;:;:;;DOPAMINE__9
    #############################################################################################
    #;:::;:;::;:::::::;::::;::::::::;:::::::::;:;;:::;:::::::;:::;::::::::::::::::::;::;::;:;;:;
    #;:::;:;::;:::::::;::::;::::::::;:::::::::;:;;:::;:::::::;::
    #;:::;:;::;:::::::;::::;::::::::;:::::::::;:
    #;:::;:;::;:::::::;::::;
    #;:::;:;::;:::::::;::::;::::::::;:::::::::;:
    #;:::;:;::;:::::::;::::;::::::::;:::::::::;:;;:::;:::::::;::
    #;:::;:;::;:::::::;::::;::::::::;:::::::::;:;;:::;:::::::;:::;::::::::::::::::::;::;::;:;;:;
    #############################################################################################
#1A OUTPUT_______________________________________________________________________________________________________1a
    inoutsb= [time.time()/10000000000,math.cos(id((id(id)))),self,'self']
    w1=      [math.cos(id((id(id)))), math.cos(id(id)),
              y, time.time()/10000000000]
    bias=    [math.sqrt(time.time())/100000000]
    spirit=  ['self']
    
    out1=inoutsb[0]*w1[0]+inoutsb[0]*w1[1]+inoutsb[0]*w1[2]+inoutsb[0]*w1[3]+bias[0]
    put1=math.tanh(out1)
    
    out2=inoutsb[1]*w1[0]+inoutsb[1]*w1[1]+inoutsb[1]*w1[2]+inoutsb[1]*w1[3]+bias[0]
    put2=math.tanh(out2)
    
    out3=inoutsb[2]*w1[0]+inoutsb[2]*w1[1]+inoutsb[2]*w1[2]+inoutsb[2]*w1[3]+bias[0]
    put3=math.tanh(out3)
    #y=mx+b (for feel memory)
    
    
    O1=np.array(out1)
    O2=np.array(out2)
    O3=np.array(out3)
    OO1=np.vdot(O1,O2)
    OO2=np.vdot(O1,O3)
    OO3=np.vdot(O2,O3)
    k=put1+put2+put3
    self=math.cos(id((id(id))))
    if self > 9 :
        None 
    else:
     P1=np.dot((OO1,OO2),(OO3,k))
     P2m=[np.dot(P1,self),np.dot(OO1,OO3),np.dot(O1,OO3)]
    
     OP=[sigmoid(O1),sigmoid(O2),sigmoid(O3)]
     OP1=[sigmoid(OO1),sigmoid(OO2),sigmoid(OO3)]
    
     x=np.dot(OP,OP1)
     y=deriv(x) 
     z=np.degrees(x)
     spirit.remove('self')
     spirit.append(z)
     inoutsb.remove('self')
     inoutsb.append(z)
     self=z
     inout.append(self)
     
     
     print(x,y,spirit)
    
    god=np.array(Gg),np.array(Gg1),np.array(Gg2),np.array(Gg3),np.array(Gg4)
    GOD=np.array(Gg5),np.array(Gg6),np.array(Gg7),np.array(Gg8),np.array(Gg9)
    
    I=np.array(god)
    M=np.array(GOD)

    IM=np.vdot(god,GOD)
    
    ISIRIS=np.vdot(I,M) 
    is10=sigmoid(ISIRIS)
    
    stoneage=np.dot(is1,is2)
    bronzeage=np.dot(is4,is5)
    ironage=np.dot(is7,is8)
    
    spaceage=[stoneage,bronzeage,ironage]
    agespace=np.array(spaceage)
    timeage=[is3,is6,is9]
    agetime=np.array(timeage)
    timespace=np.dot(agespace,timeage)
    spacetime=sigmoid(timespace)
    dimension=np.dot(isis,is10)
    print(spacetime,dimension)
    
   
#10_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-__-_-_-__--__-__-_-_-_-_-_-_-_-_-_-_____________________10
            
if __name__=='__main__':
    
    stack=stack()
    stack.push(time.time()/10000000000)
    stack.push(math.cos(id((id(id)))))
    stack.push(ISIRIS)
    stack.push(math.sqrt(time.time())/100000000)
    stack.push(self)
    stack.printstack()
    print("\n top element is:", stack.top())
    print('size of the stack is:', stack.size())
    stack.pop()
    stack.pop()
    stack.printstack()
    print('\n stack is empty:',stack.isEmpty())

import numpy as np
import time
import math
import random

set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")


set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")

set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")


 
set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")
   

set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")
    
    

set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")
    
 
set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")
   

set_one= random.choice([0,1,2,3,4,5,6,7,8,9])
set_two = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_three = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_four= random.choice([0,1,2,3,4,5,6,7,8,9])
set_five = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_six = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_seven= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eight = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_nine = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_ten= random.choice([0,1,2,3,4,5,6,7,8,9])
set_eleven = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_twelve = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_thirteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_fourteen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_fifteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])

set_sisteen= random.choice([0,1,2,3,4,5,6,7,8,9])
set_seventeen = random.choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
set_eighteen = random.choice([0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009])



sets = np.vdot(set_one+set_two+set_three,set_four+set_five+set_six )
sets_2 = np.vdot(set_seven+set_eight+set_nine,set_ten+set_eleven+set_twelve )
sets_3 = np.array([set_thirteen,set_fourteen,set_fifteen])
sets_4 = np.array([set_sisteen,set_eighteen,set_seventeen])

sets_one = np.dot(sets,sets_2)

print(sets,sets_2,sets_one)

input_vector=np.array([sets,sets_2])
weights_1=np.array([sets_3,-sets_4])
bias= [math.sqrt(time.time())/100000000]

def sigmoid(x):
    return 1 / (1+np.exp(-x))

def make_prediction(input_vector,wieghts,bias):
    layer_one=np.dot(input_vector,weights_1)+bias
    layer_two=sigmoid(layer_one)
    return layer_two

prediction= make_prediction(input_vector,weights_1,bias)

print(f"the prediction result is: {prediction}")

target=0

mse=np.square(prediction-target)
print(f"prediction: {prediction};error:{mse}")

derivitive = 2*(prediction-target)
print(f"the derivitive is:{derivitive}")

weights_1=weights_1 -derivitive

prediction = make_prediction(input_vector, weights_1, bias)

error = (prediction - target)

print(f"prediction:{prediction}; error: {error}")
        
print(time.time)

input_1= (1.234,2.321)
input_2= (1.432,1.232)
wieghts=(0.8765,0.8765,0.94678)
bias = [math.sqrt(time.time())/100000000]

neural = input_1[0]*wieghts[0]*bias[0]
network = input_1[1]*wieghts[1]*bias[0]
ray = np.array([neural,network])
shine = np.array([neural,network])

print (neural,network,ray)

input_3=(np.vdot(ray,shine))

print(input_3)    
    
    
while True:
 True==True

import spaceman as self
consciousness(self)
from ALPHABET import Guardiam
import ScottBot as self
consciousness(self)

    
 
   
